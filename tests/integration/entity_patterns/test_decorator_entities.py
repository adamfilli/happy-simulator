"""Integration tests for @simulatable decorated entities.

These tests verify that decorated classes (without Entity inheritance)
work correctly in full simulation scenarios with Sources, Events, and
the simulation loop.
"""

from dataclasses import dataclass
from typing import Generator, List

import pytest

from happysimulator.core.decorators import simulatable
from happysimulator.core.event import Event
from happysimulator.core.temporal import Instant
from happysimulator.core.simulation import Simulation
from happysimulator.load.event_provider import EventProvider
from happysimulator.load.source import Source


# --- Decorated Entities ---

@simulatable
class TickCounter:
    """Counts events without inheriting from Entity."""

    def __init__(self, name: str):
        self.name = name
        self.count = 0
        self.timestamps: list[Instant] = []

    def handle_event(self, event: Event) -> None:
        self.count += 1
        self.timestamps.append(self.now)


@simulatable
class EchoServer:
    """Server that echoes requests back to a client after a delay."""

    def __init__(self, name: str, processing_delay: float = 0.1):
        self.name = name
        self.processing_delay = processing_delay
        self.requests_handled = 0

    def handle_event(self, event: Event) -> Generator[float, None, List[Event]]:
        self.requests_handled += 1
        yield self.processing_delay

        # Send response back via Event.once wrapping the client method
        client = event.context.get("metadata", {}).get("client")
        if client:
            response = Event.once(
                time=self.now,
                event_type="Response",
                fn=client.receive_response,
            )
            return [response]
        return []


@simulatable
class SimpleClient:
    """Client that sends requests and receives responses."""

    def __init__(self, name: str):
        self.name = name
        self.requests_sent = 0
        self.responses_received = 0

    def send_request(self, event: Event) -> List[Event]:
        self.requests_sent += 1
        return []

    def receive_response(self, event: Event) -> None:
        self.responses_received += 1

    def handle_event(self, event: Event) -> None:
        pass


# --- Event Providers (kept for RequestProvider with custom logic) ---

class RequestProvider(EventProvider):
    """Generates request events from client to server."""

    def __init__(self, client: SimpleClient, server: EchoServer):
        super().__init__()
        self.client = client
        self.server = server
        self.request_count = 0

    def get_events(self, time: Instant) -> List[Event]:
        self.request_count += 1
        event = Event(
            time=time,
            event_type=f"Request-{self.request_count}",
            target=self.server,
        )
        event.add_context("client", self.client)
        self.client.requests_sent += 1
        return [event]


# --- Tests ---

class TestDecoratedCounterSimulation:
    """Test decorated counter in a simulation with a Source."""

    def test_counter_receives_events_from_source(self):
        """Decorated counter counts events generated by a Source."""
        counter = TickCounter("counter")

        source = Source.constant(rate=10.0, target=counter, event_type="Tick", name="ticker")

        sim = Simulation(
            start_time=Instant.Epoch,
            duration=1.0,
            sources=[source],
            entities=[counter],
        )
        sim.run()

        # At 10/sec for 1 second, expect ~10 events (plus one at t=0.1)
        assert counter.count == 10
        assert len(counter.timestamps) == 10

    def test_counter_timestamps_are_monotonic(self):
        """Event timestamps should be monotonically increasing."""
        counter = TickCounter("counter")

        source = Source.constant(rate=5.0, target=counter, event_type="Tick", name="ticker")

        sim = Simulation(
            start_time=Instant.Epoch,
            duration=2.0,
            sources=[source],
            entities=[counter],
        )
        sim.run()

        # Verify timestamps are strictly increasing
        for i in range(1, len(counter.timestamps)):
            assert counter.timestamps[i] > counter.timestamps[i - 1]


class TestDecoratedClientServerSimulation:
    """Test decorated client-server interaction."""

    def test_server_processes_requests_and_sends_responses(self):
        """Server handles requests and sends responses back to client."""
        client = SimpleClient("client")
        server = EchoServer("server", processing_delay=0.05)

        # Manually schedule a few requests instead of using a Source
        # This gives us precise control over timing
        sim = Simulation(
            start_time=Instant.Epoch,
            duration=1.0,
            entities=[client, server],
        )

        # Schedule 3 requests
        for i in range(3):
            event = Event(
                time=Instant.from_seconds(0.1 * (i + 1)),
                event_type=f"Request-{i + 1}",
                target=server,
            )
            event.add_context("client", client)
            sim.schedule(event)

        sim.run()

        assert server.requests_handled == 3
        assert client.responses_received == 3

    def test_server_generator_yields_correctly(self):
        """Server's generator-based processing introduces correct delay."""
        client = SimpleClient("client")
        server = EchoServer("server", processing_delay=0.2)

        sim = Simulation(
            start_time=Instant.Epoch,
            duration=1.0,
            entities=[client, server],
        )

        # Single request at t=0.1
        event = Event(
            time=Instant.from_seconds(0.1),
            event_type="Request",
            target=server,
        )
        event.add_context("client", client)
        sim.schedule(event)

        sim.run()

        # Server should have processed 1 request
        assert server.requests_handled == 1
        # Client should have received response (after 0.2s delay)
        assert client.responses_received == 1


class TestMixedEntityTypes:
    """Test that decorated and Entity-based classes can coexist."""

    def test_decorated_and_inherited_together(self):
        """Simulation can contain both Entity subclasses and decorated classes."""
        from happysimulator.core.entity import Entity

        # Traditional Entity subclass
        class TraditionalCounter(Entity):
            def __init__(self, name: str):
                super().__init__(name)
                self.count = 0

            def handle_event(self, event: Event) -> None:
                self.count += 1

        # Decorated class
        @simulatable
        class DecoratedCounter:
            def __init__(self, name: str):
                self.name = name
                self.count = 0

            def handle_event(self, event: Event) -> None:
                self.count += 1

        traditional = TraditionalCounter("traditional")
        decorated = DecoratedCounter("decorated")

        sim = Simulation(
            start_time=Instant.Epoch,
            duration=1.0,
            entities=[traditional, decorated],
        )

        # Schedule events for both
        sim.schedule(Event(
            time=Instant.from_seconds(0.1),
            event_type="ping",
            target=traditional,
        ))
        sim.schedule(Event(
            time=Instant.from_seconds(0.2),
            event_type="ping",
            target=decorated,
        ))
        sim.schedule(Event(
            time=Instant.from_seconds(0.3),
            event_type="ping",
            target=traditional,
        ))

        sim.run()

        assert traditional.count == 2
        assert decorated.count == 1
